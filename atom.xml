<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>astrawberry</title>
  
  <subtitle>哪怕你周围的世界再复杂，也要保护好内心的善良和温暖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://one-strawberry.github.io/"/>
  <updated>2020-04-10T12:28:11.283Z</updated>
  <id>https://one-strawberry.github.io/</id>
  
  <author>
    <name>Strawberry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器事件循环</title>
    <link href="https://one-strawberry.github.io/js/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>https://one-strawberry.github.io/js/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-04-10T12:28:11.283Z</published>
    <updated>2020-04-10T12:28:11.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Event-Loop-事件循环"><a href="#Event-Loop-事件循环" class="headerlink" title="Event Loop 事件循环"></a>Event Loop 事件循环</h1><h3 id="CPU、进程、线程之间的关系"><a href="#CPU、进程、线程之间的关系" class="headerlink" title="CPU、进程、线程之间的关系"></a>CPU、进程、线程之间的关系</h3><ul><li>cpu 是计算机的核心，承担了所有计算机的任务</li><li>进程 cpu 资源分配的最小单位</li><li>线程 cpu 调度的最小单位</li></ul><p>三者之间的的关系在之前看到的一篇文章里说就好比一个工厂，这个工厂就是 cpu。<br>工厂每次只能提供一个车间的电力，也就是当一个车间开工的时候，其它所有车间不能工作。<br>这就意味着一个 cpu 一次只能运行一个任务，而进程就是这一个个车间。任何时刻，cpu 都只能进行一个进程，其他进程就进入了非运行状态。<br>每个车间里面有很多的工人，这些工人共享一个车间。<br>这就相当于一个进程可以存在多个线程，多个线程共享进程的资源。</p><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>浏览器是多进程的，大家可以打开任务管理器，在进程中看看 Chrome 浏览器（或任意浏览器打开多个 tab 页面）：<br><img src="/images/2.png" alt=""></p><h3 id="浏览器进程分类"><a href="#浏览器进程分类" class="headerlink" title="浏览器进程分类"></a>浏览器进程分类</h3><ul><li><p>Browser 进程<br>浏览器的主进程，负责协调控制其它子进程</p></li><li><p>第三方插件进程<br>每使用一个插件，相当于一个进程，只有在使用该插件的时候创建</p></li><li><p>GPU 进程<br>最多一个，用于 3D 绘制</p></li><li><p>浏览器渲染进程（内核）<br>默认每个 Tab 页面一个进程，互不影响<br>控制页面渲染，脚本执行，事件处理等</p><h4 id="浏览器渲染进程（内核）"><a href="#浏览器渲染进程（内核）" class="headerlink" title="浏览器渲染进程（内核）"></a>浏览器渲染进程（内核）</h4><p>渲染进程当然存在多个线程啦，让我们来看看吧：</p><ul><li><p>GUI 线程<br>负责渲染浏览器界面，解析 HTML、CSS。<br>当页面重绘或者引发回流的时候，该线程会执行<br>该线程与 JS 引擎线程是互斥的，二者不可以同时进行</p></li><li><p>JS 引擎线程<br>负责 js 脚本程序<br>只有一个 js 引擎线程<br>同样，与 GUI 线程互斥</p></li><li><p>事件触发线程<br>用来控制事件循环<br>当 js 引擎执行代码时，会将对应任务添加到事件触发线程中<br>当对应事件触发，线程会把事件添加到任务队列队尾，等待响应</p></li><li><p>定时触发线程<br>setInterval()和 setTimeout()所在的线程<br>定时任务不是由 js 引擎计数的</p></li><li><p>异步 http 请求线程<br>浏览器有一个单独的线程用于处理 ajax 请求</p><blockquote><p>GUI 渲染线程和 JS 引擎线程互斥： 因为 js 时可以操作 DOM 的，如果在修改这些元素属性的时候同时渲染页面，那渲染前后获得的元素数据可能会不一致。所以为防止渲染出现不可预期的结果，浏览器设置了二者是互斥的。</p></blockquote></li></ul></li></ul><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><ul><li>js 分为同步任务和异步任务</li><li>同步任务在 js 引擎线程上执行，形成一个执行栈</li><li>事件触发线程管理一个任务队列</li></ul><p>定时触发线程本身是一个同步任务，但其中的回调函数是异步任务，所以 js 引擎线程会通知定时器触发线程，当定时器触发线程接收到消息后，会在等待的时间后将回调函数放入到任务队列中去</p><p>同样，异步 http 请求线程会接收到一个来自 js 引擎线程的通知，发送一个网络请求，当异步 http 请求线程接收到消息后，在请求成功后，将回调函数放入任务队列中去</p><ul><li>当执行栈中同步任务执行完毕，js 引擎线程空闲，系统会自动识别任务队列，将可运行的异步任务添加到执行栈中。</li></ul><p>用一张图来解释，可能更加清楚：</p><p><img src="/images/1.png" alt=""></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><blockquote><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop 的走向和取值。</p></blockquote><h4 id="什么是宏任务"><a href="#什么是宏任务" class="headerlink" title="什么是宏任务"></a>什么是宏任务</h4><p>我们将每次执行栈执行的代码当作一个宏任务,前文中提到过 GUI 渲染线程和 js 引擎线程，它们二者是互斥的，浏览器为了使宏任务和 DOM 任务有序进行，会在一个宏任务执行之后，下一个宏任务执行之前，对页面进行渲染。</p><p>宏任务有：</p><ul><li>整体代码 script</li><li>setInterval()</li><li>setTImeout()</li><li>…</li></ul><h4 id="什么是微任务"><a href="#什么是微任务" class="headerlink" title="什么是微任务"></a>什么是微任务</h4><p>微任务可以理解为在宏任务执行后立马执行的任务，也就是说，当宏任务执行后，在渲染页面前，将所有的微任务执行完，再进行页面的渲染</p><p>微任务有:</p><ul><li>原生 Promise</li><li>process.nextTick</li></ul><h4 id="如何区分宏任务与微任务"><a href="#如何区分宏任务与微任务" class="headerlink" title="如何区分宏任务与微任务"></a>如何区分宏任务与微任务</h4><ul><li>宏任务是 js 宿主提供的<br>目前较为常见宿主有浏览器和 node</li><li>微任务是语言标准（js 本身）提供的<br>javascript 是由 ECMA 制定标准的，所以语言标准提供的就是微任务，如 ES6 中提供的 Promise<br>综上所述，setTimeout 是宿主提供的，Promise 是 ES6 提供的，所以 Promise 会比 setTimeout 定时器更早执行。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用一幅图来总结吧~<br><img src="/images/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Event-Loop-事件循环&quot;&gt;&lt;a href=&quot;#Event-Loop-事件循环&quot; class=&quot;headerlink&quot; title=&quot;Event Loop 事件循环&quot;&gt;&lt;/a&gt;Event Loop 事件循环&lt;/h1&gt;&lt;h3 id=&quot;CPU、进程、线程之间的关
      
    
    </summary>
    
    
      <category term="js" scheme="https://one-Strawberry.github.io/categories/js/"/>
    
    
      <category term="事件循环" scheme="https://one-Strawberry.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于babel你需要知道</title>
    <link href="https://one-strawberry.github.io/uncategorized/%E5%85%B3%E4%BA%8Ebabel%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93/"/>
    <id>https://one-strawberry.github.io/uncategorized/%E5%85%B3%E4%BA%8Ebabel%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93/</id>
    <published>2020-04-10T12:28:11.282Z</published>
    <updated>2020-04-10T12:28:11.282Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
